/*
 * This program is free software; you can use it, redistribute it
 * and / or modify it under the terms of the GNU General Public License
 * (GPL) as published by the Free Software Foundation; either version 3
 * of the License or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program, in a file called gpl.txt or license.txt.
 *  If not, write to the Free Software Foundation Inc.,
 *  59 Temple Place - Suite 330, Boston, MA  02111-1307 USA
 */
#include "settings.h"

#include <FS.h>
#include <ArduinoJson.h>

SettingsClass::SettingsClass() = default;

void SettingsClass::readJson(JsonDocument &doc) {
    General.readJson(doc);
    WiFi.readJson(doc);
    OBD2.readJson(doc);
}

void SettingsClass::writeJson(JsonDocument &doc) {
    General.writeJson(doc);
    WiFi.writeJson(doc);
    OBD2.writeJson(doc);
}

bool SettingsClass::readSettings(fs::FS &fs) {
    bool success = false;

    File file = fs.open(SETTINGS_FILE, FILE_READ);
    if (file && !file.isDirectory()) {
        JsonDocument doc;
        if (!deserializeJson(doc, file)) {
            readJson(doc);
            validateSettings(); // Validate after reading from file
            success = true;
        }
        file.close();
    }

    return success;
}

bool SettingsClass::writeSettings(fs::FS &fs) {
    bool success = false;

    File file = fs.open(SETTINGS_FILE, FILE_WRITE);
    if (!file) {
        Serial.println("Failed to open file settings.json for writing.");
        return false;
    }

    JsonDocument doc;
    writeJson(doc);
    success = serializeJson(doc, file);

    file.close();

    return success;
}

void SettingsClass::validateSettings() const {
    Serial.println("Validating general settings configurations...");
    bool overallSettingsOk = true; // To track if any critical warnings occurred

    // General settings
    if (this->General.getSleepDuration() <= 0) {
        Serial.println("Settings: WARNING - General.sleepDuration is <= 0. Device may not sleep as expected.");
        // overallSettingsOk = false; // Consider if this should make overallSettingsOk false
    }
    if (this->General.getSleepTimeout() < 0) {
        Serial.println("Settings: WARNING - General.sleepTimeout is negative. This might be unintended.");
    }

    // WiFi settings
    // Accessing wifi.ssid directly as getAPSSID has logic for alternate.
    // We need to check the actual stored value. WiFi.wifi.ssid
    if (strlen(this->WiFi.wifi.ssid) == 0) {
        Serial.println("Settings: INFO - WiFi.apSSID is empty. A default SSID will likely be generated by the system.");
    }

    // OBD2 settings
    if (strlen(this->OBD2.obd2.name) == 0 && strlen(this->OBD2.obd2.mac) == 0) {
        Serial.println("Settings: WARNING - OBD2.name and OBD2.mac are both empty. Device discovery will be attempted, which might be unreliable if multiple adapters are present.");
    }
    char p = this->OBD2.getProtocol(); // getProtocol() is fine here
    // Check if protocol is a standard numeric digit (0-9) or uppercase hex char (A-F)
    // AT TP0 to AT TPDA (protocol 0 to 13 in decimal)
    // '0' is auto, '1'-'9', 'A'-'D' (or 'C' depending on ELM version for user defined)
    bool isValidProtocolChar = (p >= '0' && p <= '9') || (p >= 'A' && p <= 'F') || (p >= 'a' && p <= 'f');
    if (!isValidProtocolChar) {
         Serial.printf("Settings: WARNING - OBD2.protocol ('%c') is not a standard alphanumeric protocol character (0-9, A-F). Ensure it's valid for AT TP command.\n", p);
    }

    // MQTT settings are not part of SettingsClass::readJson/writeJson, so skipping detailed validation here.

    if (overallSettingsOk) {
        Serial.println("Settings validation: Checks passed or only informational messages issued.");
    } else {
        Serial.println("Settings validation: One or more critical settings have warnings/errors. Please review configuration.");
    }
}

std::string SettingsClass::buildJson() {
    std::string payload;

    JsonDocument doc;
    writeJson(doc);
    serializeJson(doc, payload);

    return payload;
}

bool SettingsClass::parseJson(std::string json) {
    bool success = false;
    JsonDocument doc;
    if (!deserializeJson(doc, json)) {
        readJson(doc);
        validateSettings(); // Validate after parsing
        success = true;
    }

    return success;
}

void GeneralSettings::readJson(JsonDocument &doc) {
    general.sleepTimeout = doc["general"]["sleepTimeout"] | 5 * 60;
    general.sleepDuration = doc["general"]["sleepDuration"] | 60 * 60;
}

void GeneralSettings::writeJson(JsonDocument &doc) {
    doc["general"]["sleepTimeout"] = general.sleepTimeout;
    doc["general"]["sleepDuration"] = general.sleepDuration;
}

int GeneralSettings::getSleepTimeout() const {
    return general.sleepTimeout;
}

void GeneralSettings::setSleepTimeout(const int timeout) {
    general.sleepTimeout = timeout;
}

int GeneralSettings::getSleepDuration() const {
    return general.sleepDuration;
}

void GeneralSettings::setSleepDuration(const int time) {
    general.sleepDuration = time;
}

void WiFiSettings::readJson(JsonDocument &doc) {
    strlcpy(wifi.ssid, doc["wifi"]["ssid"] | "", sizeof(wifi.ssid));
    strlcpy(wifi.password, doc["wifi"]["password"] | "", sizeof(wifi.password));
}

void WiFiSettings::writeJson(JsonDocument &doc) {
    doc["wifi"]["ssid"] = wifi.ssid;
    doc["wifi"]["password"] = wifi.password;
}

String WiFiSettings::getAPSSID(const String &alternate) const {
    if (strlen(wifi.ssid) == 0) {
        return alternate;
    }
    return wifi.ssid;
}

void WiFiSettings::setAPSSID(const char *ssid) {
    strlcpy(wifi.ssid, ssid, sizeof(wifi.ssid));
}

String WiFiSettings::getAPPassword() const {
    return wifi.password;
}

void WiFiSettings::setAPPassword(const char *password) {
    strlcpy(wifi.password, password, sizeof(wifi.password));
}

void OBD2Settings::readJson(JsonDocument &doc) {
    strlcpy(obd2.name, doc["obd2"]["name"] | "", sizeof(obd2.name));
    strlcpy(obd2.mac, doc["obd2"]["mac"] | "", sizeof(obd2.mac));
    obd2.checkPIDSupport = doc["obd2"]["checkPIDSupport"] | false;
    obd2.debug = doc["obd2"]["debug"] | false;
    obd2.specifyNumResponses = doc["obd2"]["specifyNumResponses"] | true;
    obd2.protocol = doc["obd2"]["protocol"] | '0';
}

void OBD2Settings::writeJson(JsonDocument &doc) {
    doc["obd2"]["name"] = obd2.name;
    doc["obd2"]["mac"] = obd2.mac;
    doc["obd2"]["checkPIDSupport"] = obd2.checkPIDSupport;
    doc["obd2"]["debug"] = obd2.debug;
    doc["obd2"]["specifyNumResponses"] = obd2.specifyNumResponses;
    doc["obd2"]["protocol"] = obd2.protocol;
}

String OBD2Settings::getName(const String &alternate) const {
    if (strlen(obd2.name) == 0) {
        return alternate;
    }
    return obd2.name;
}

void OBD2Settings::setName(const char *name) {
    strlcpy(obd2.name, name, sizeof(obd2.name));
}

String OBD2Settings::getMAC() const {
    return obd2.mac;
}

void OBD2Settings::setMAC(const char *mac) {
    strlcpy(obd2.mac, mac, sizeof(obd2.mac));
}

bool OBD2Settings::getCheckPIDSupport() const {
    return obd2.checkPIDSupport;
}

void OBD2Settings::setCheckPIDSupport(bool checkPIDSupport) {
    obd2.checkPIDSupport = checkPIDSupport;
}

bool OBD2Settings::getDebug() const {
    return obd2.debug;
}

void OBD2Settings::setDebug(bool debug) {
    obd2.debug = debug;
}

bool OBD2Settings::getSpecifyNumResponses() const {
    return obd2.specifyNumResponses;
}

void OBD2Settings::setSpecifyNumResponses(bool specifyNumResponses) {
    obd2.specifyNumResponses = specifyNumResponses;
}

char OBD2Settings::getProtocol() const {
    return obd2.protocol;
}

void OBD2Settings::setProtocol(char protocol) {
    obd2.protocol = protocol;
}

SettingsClass Settings;
